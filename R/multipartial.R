#' @title Multispecies partial plots (in development)
#'
#' @description
#'
#' Partial dependence plots show the response curves of an individual variable
#' in the sum-of-trees models. The main line is the average of partial
#' dependence plots for each posterior draw of sum-of-trees models; each of
#' those curves is generated by evaluating the BART model prediction at each
#' specified x value for *each other combination of other x values in the data*.
#' This is obviously computationally very expensive, and gets slower to run
#' depending on: how much smooth you add, how many variables you ask for, and
#' more posterior draws (ndpost; defaults to 1000) in the dbarts::bart() function.
#'
#' This is a somewhat altered and simplified version of partial() that allows
#' you to combine different species' responses to the same variables on the
#' same axes. Run the models separately, then use this function to combine them.
#'
#' @param model A dbarts model object
#' @param x.vars A list of the variables for which you want to run the partials.
#' Defaults to doing all of them.
#' @param smooth A multiplier for how much smoother you want the sampling of the
#' levels to be. High values, like 10 or over, are obviously much slower and
#' don't add much.
#' @param trace Traceplots for each individual draw from the posterior
#' @param transform This converts from the logit output of [dbarts:::predict] to
#' actual 0 to 1 probabilities. I wouldn't turn this off unless you're really
#' interested in a deep dive on the model.
#' @param panels For multiple variables, use this to create a multipanel figure.
#'
#'
#' @return Returns a ggplot object or cowplot object.
#'
#' @examples
#' f <- function(x) {
#'   return(0.5 * x[, 1] + 3 * x[, 2] * x[, 3]) - 5 * x[, 4]
#' }
#' g <- function(x) {
#'   return(0.6 * (x[, 1] - 0.3) + 1 * x[, 2] * x[, 3]) - 5 * x[, 4]
#' }
#' sigma <- 0.2
#' n <- 100
#' x <- matrix(2 * runif(n * 3) - 1, ncol = 3)
#' x <- data.frame(x)
#' x[, 4] <- rbinom(100, 1, 0.3)
#' colnames(x) <- c("rob", "hugh", "ed", "phil")
#' Ey <- f(x)
#' y <- rnorm(n, Ey, sigma)
#' Ez <- g(x)
#' z <- rnorm(n, Ez, sigma)
#' df <- data.frame(z, y, x)
#' set.seed(99)
#'
#' bartFit1 <- dbarts::bart(y ~ rob + hugh + ed + phil, df,
#'   keepevery = 10, ntree = 100, keeptrees = TRUE
#' )
#'
#' bartFit2 <- dbarts::bart(z ~ rob + hugh + ed + phil, df,
#'   keepevery = 10, ntree = 100, keeptrees = TRUE
#' )
#'
#' model.list <- list(bartFit1, bartFit2)
#'
#' multipartial(
#'   modl = model.list, spnames = c("Y", "Z"),
#'   x.vars = c("rob", "hugh"),
#'   smooth = 7, trace = TRUE, panels = TRUE
#' )
#'
#' @export
#'
#'

multipartial <- function(modl, spnames, x.vars = NULL,
                         smooth = 7, trace = TRUE,
                         transform = TRUE, panels = FALSE) {

  # A couple errors in case I'm Idiot

  if (smooth > 10) {
    warning("You have chosen way, way too much smoothing... poorly")
  }

  if (!is.null(x.vars) && length(x.vars) == 1 && panels == TRUE) {
    stop("Hey bud, you can't do several panels on only one variable!")
  }

  # Actually build each partial

  pd.get <- function(model) {
    if (is.null(x.vars)) {
      raw <- model$fit$data@x
    } else {
      raw <- model$fit$data@x[, x.vars]
    }

    if (!is.null(x.vars) && length(x.vars) == 1) {
      minmax <- data.frame(
        mins = min(raw),
        maxs = max(raw)
      )
    } else {
      minmax <- data.frame(
        mins = apply(raw, 2, min),
        maxs = apply(raw, 2, max)
      )
    }
    lev <- lapply(seq_len(nrow(minmax)), function(i) {
      seq(
        minmax$mins[i], minmax$maxs[i],
        (minmax$maxs[i] - minmax$mins[i]) / (10 * smooth)
      )
    })

    for (i in seq_along(lev)) {
      if (length(lev) == 1) {
        if (length(unique(raw)) == 2) {
          lev[[i]] <- unique(raw)
        }
      } else {
        if (length(unique(raw[, i])) == 2) {
          lev[[i]] <- unique(raw[, i])
        }
      }
    }

    pd <- dbarts::pdbart(model, xind = x.vars, levs = lev, pl = FALSE)
  }

  pdl <- lapply(modl, pd.get)

  # Generate the partial visualizations in ggplot


  plots <- list()

  for (i in seq_along(pdl[[1]]$fd)) {
    for (j in seq_along(pdl)) {
      q50f <- function(x) {
        apply(x$fd[[i]], 2, median)
      }
      q50 <- data.frame(lapply(pdl, q50f))
      colnames(q50) <- spnames
      if (transform == TRUE) {
        q50 <- apply(q50, 2, pnorm)
      }
      df <- q50 %>%
        tibble::as_tibble() %>%
        dplyr::mutate(x = pdl[[1]]$levs[[i]])
    }

    df <- df %>%
      tidyr::pivot_longer(-x) %>%
      dplyr::rename(Species = name)

    if (trace == TRUE) {
      ff <- function(x) {
        data.frame(t(x$fd[[i]]))
      }
      f <- lapply(pdl, ff)
      traces <- lapply(seq_along(pdl), function(k) {
        colnames(f[[k]]) <- gsub("X", "iter", colnames(f[[k]]), fixed = TRUE)
        x.i <- df %>%
          filter(Species == spnames[k]) %>%
          dplyr::pull(x)
        f[[k]]$x <- x.i
        f[[k]]$Species <- spnames[k]
        f[[k]]
      })
      traces <- do.call("rbind", traces)
      df <- dplyr::left_join(df, traces)
    }

    # if(transform==TRUE) {df %>% dplyr::mutate(value = stats::pnorm(value)) -> df}

    g <- ggplot2::ggplot(df, ggplot2::aes(x = x, y = value, colour = Species)) +
      ggplot2::labs(title = pdl[[1]]$xlbs[[i]], y = "", x = "") +
      ggplot2::theme_light(base_size = 16) +
      ggplot2::theme(
        plot.title = ggplot2::element_text(hjust = 0.5),
        axis.title.y = ggplot2::element_text(vjust = 1.7)
      )

    if (trace) {
      if (transform) {
        for (j in seq(3, ncol(df))) {
          g <- g +
            ggplot2::geom_line(
              ggplot2::aes_string(
                y = stats::pnorm(dplyr::pull(df[, j]))
              ),
              alpha = 0.025
            )
        }
      } else {
        for (j in seq(3, ncol(df))) {
          g <- g +
            ggplot2::geom_line(
              ggplot2::aes_string(y = dplyr::pull(df[, j])),
              alpha = 0.025
            )
        }
      }
    }

    g <- g + ggplot2::geom_line(size = 1.25)

    if (!panels) {
      g <- g +
        ggplot2::theme(
          plot.margin = ggplot2::unit(c(0.5, 0.5, 0.5, 0.5), "cm")
        )
    } else {
      g <- g +
        ggplot2::theme(
          plot.margin = ggplot2::unit(c(0.15, 0.15, 0.15, 0.15), "cm")
        )
    }
    plots[[i]] <- g
  }

  # Return them

  if (panels) {
    return(patchwork::wrap_plots(plotlist = plots, guides = "collect"))
  } else {
    return(plots)
  }
}

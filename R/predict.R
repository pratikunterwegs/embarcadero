
#' @title predict() for spatial use of BART models
#'
#' @description
#' A predict() wrapper for combining BART models with spatial input data, to
#' generate a Raster or RasterStack of predicted outputs. This now includes the
#' ability to predict from random intercept models, which can be used to deal
#' with clustering in space and time of outcome variables!
#'
#' @param object A BART model objector riBART model object generated by the
#' `dbarts` package
#' @param x.layers An object of class `RasterStack`
#' @param quantiles Include the extraction of quantiles
#' (e.g. 5\% and 95\% credible interval) from the posterior
#' @param ri.data If 'object' is a riBART model, this gives either one
#' consistent value (e.g. a prediction year) or a RasterLayer for the random
#' effect
#' @param ri.name The name of the random intercept in the riBART model
#' @param ri.pred Should the random intercept be *included* in the prediction
#' value or dropped? Defaults to FALSE (treats the random intercept as noise
#' to be excluded)
#' @param splitby If set to a value higher than 1, will split your dataset into
#' approximately n divisible chunks
#' @param quiet No progress bars
#'
#' @export
#'

predict2.bart <- function(object,
                          x.layers,
                          quantiles = numeric(),
                          ri.data = NULL,
                          ri.name = NULL,
                          ri.pred = FALSE,
                          splitby = 1,
                          quiet = FALSE) {
  if (inherits(object, "rbart")) {
    if (is.null(ri.data)) {
      stop("ERROR: Input either a value or a raster in ri.data")
    }
    if (is.null(ri.name)) {
      stop(
        paste(
          "ERROR: Input the correct random effect variable name in the model",
          "object in ri.name",
          collapse = " "
        )
      )
    }
  }

  if (inherits(object, "rbart")) {
    xnames <- attr(object$fit[[1]]$data@x, "term.labels")
    if (all(xnames %in% c(names(x.layers), ri.name))) {
      x.layers <- x.layers[[xnames[!(xnames == ri.name)]]]
    } else {
      stop("Variable names of RasterStack don't match the requested names")
    }
  }
  if (inherits(object, "bart")) {
    xnames <- attr(object$fit$data@x, "term.labels")
    if (all(xnames %in% names(x.layers))) {
      x.layers <- x.layers[[xnames]]
    } else {
      stop("Variable names of RasterStack don't match the requested names")
    }
  }

  input.matrix <- as.matrix(raster::raster::getValues(x.layers))
  blankout <- data.frame(matrix(
    ncol = (1 + length(quantiles)),
    nrow = ncell(x.layers[[1]])
  ))
  whichvals <- which(complete.cases(input.matrix))
  input.matrix <- input.matrix[complete.cases(input.matrix), ]

  if (inherits(object, "rbart")) {
    if (inherits(ri.data, "RasterLayer")) {
      input.matrix <- cbind(input.matrix, values(ri.data))
    } else {
      input.matrix <- cbind(input.matrix, rep(ri.data, nrow(input.matrix)))
    }
    colnames(input.matrix)[ncol(input.matrix)] <- ri.name
  }

  if (splitby == 1) {
    if (inherits(object, "bart")) {
      pred <- dbarts:::predict.bart(object, input.matrix)
    } else if (inherits(object, "rbart")) {
      if (ri.pred == FALSE) {
        pred <- dbarts:::predict.rbart(object,
          input.matrix[, !(colnames(input.matrix) == ri.name)],
          group.by = input.matrix[, ri.name],
          type = "bart"
        )
      } else {
        pred <- dbarts:::predict.rbart(object,
          input.matrix[, !(colnames(input.matrix) == ri.name)],
          group.by = input.matrix[, ri.name],
          type = "ppd"
        )
      }
    }
    pred.summary <- dfextract(pred, quant = quantiles)
  } else {
    split <- floor(nrow(input.matrix) / splitby)
    input.df <- data.frame(input.matrix)
    input.str <- split(
      input.df,
      (as.numeric(seq_len(nrow(input.df))) - 1) %/% split
    )
    for (i in seq_along(input.str)) {
      if (i == 1) {
        start_time <- Sys.time()
      }

      if (inherits(object, "bart")) {
        pred <- dbarts:::predict.bart(object, input.str[[i]])
      } else if (inherits(object, "rbart")) {
        if (ri.pred == FALSE) {
          pred <- dbarts:::predict.rbart(object,
            input.str[[i]][, !(colnames(input.str[[i]]) == ri.name)],
            group.by = input.str[[i]][, ri.name],
            type = "bart"
          )
        } else {
          pred <- dbarts:::predict.rbart(object,
            input.str[[i]][, !(colnames(input.str[[i]]) == ri.name)],
            group.by = input.str[[i]][, ri.name],
            type = "ppd"
          )
        }
      }
      pred.summary <- dfextract(pred, quant = quantiles)
      input.str[[i]] <- pred.summary
      if (i == 1) {
        end_time <- Sys.time()
        cat("Estimated time to total prediction (mins):\n")
        cat(length(input.str) * as.numeric(end_time - start_time) / 60)
        cat("\n")
        if (!quiet) {
          pb <- utils::txtProgressBar(min = 0, max = length(input.str), style = 3)
        }
      }
      if (!quiet) {
        utils::setTxtProgressBar(pb, i)
      }
    }
    if (length(quantiles) == 0) {
      pred.summary <- data.frame(means = unlist(input.str))
    } else {
      pred.summary <- rbindlist(input.str)
    }
  }

  if (inherits(object, "rbart")) {
    output <- stats::pnorm(as.matrix(pred.summary))
  } else {
    output <- as.matrix(pred.summary)
  }

  blankout[whichvals, ] <- output
  output <- blankout

  outlist <- lapply(seq_along(output), function(x) {
    output.m <- t(matrix(output[, x],
      nrow = ncol(x.layers),
      ncol = nrow(x.layers)
    ))
    return(raster::raster(output.m,
      xmn = xmin(x.layers[[1]]), xmx = xmax(x.layers[[1]]),
      ymn = ymin(x.layers[[1]]), ymx = ymax(x.layers[[1]]),
      crs = x.layers[[1]]@crs
    ))
  })

  outlist <- stack(outlist)
  return(outlist)
}

dfextract <- function(df, quant) {
  if (length(quant) == 0) {
    return(colMeans(df))
  } else {
    return(cbind(
      data.frame(colMeans(df)),
      colQuantiles(df, probs = quant)
    ))
  }
}

% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/multipartial.R
\name{multipartial}
\alias{multipartial}
\title{Multispecies partial plots (in development)}
\usage{
multipartial(
  modl,
  spnames,
  x.vars = NULL,
  smooth = 7,
  trace = TRUE,
  transform = TRUE,
  panels = FALSE
)
}
\arguments{
\item{x.vars}{A list of the variables for which you want to run the partials.
Defaults to doing all of them.}

\item{smooth}{A multiplier for how much smoother you want the sampling of the
levels to be. High values, like 10 or over, are obviously much slower and
don't add much.}

\item{trace}{Traceplots for each individual draw from the posterior}

\item{transform}{This converts from the logit output of [dbarts:::predict] to
actual 0 to 1 probabilities. I wouldn't turn this off unless you're really
interested in a deep dive on the model.}

\item{panels}{For multiple variables, use this to create a multipanel figure.}

\item{model}{A dbarts model object}
}
\value{
Returns a ggplot object or cowplot object.
}
\description{
Partial dependence plots show the response curves of an individual variable
in the sum-of-trees models. The main line is the average of partial
dependence plots for each posterior draw of sum-of-trees models; each of
those curves is generated by evaluating the BART model prediction at each
specified x value for *each other combination of other x values in the data*.
This is obviously computationally very expensive, and gets slower to run
depending on: how much smooth you add, how many variables you ask for, and
more posterior draws (ndpost; defaults to 1000) in the bart() function.

This is a somewhat altered and simplified version of partial() that allows
you to combine different species' responses to the same variables on the
same axes. Run the models separately, then use this function to combine them.
}
\examples{
f <- function(x) {
  return(0.5 * x[, 1] + 3 * x[, 2] * x[, 3]) - 5 * x[, 4]
}
g <- function(x) {
  return(0.6 * (x[, 1] - 0.3) + 1 * x[, 2] * x[, 3]) - 5 * x[, 4]
}
sigma <- 0.2
n <- 100
x <- matrix(2 * runif(n * 3) - 1, ncol = 3)
x <- data.frame(x)
x[, 4] <- rbinom(100, 1, 0.3)
colnames(x) <- c("rob", "hugh", "ed", "phil")
Ey <- f(x)
y <- rnorm(n, Ey, sigma)
Ez <- g(x)
z <- rnorm(n, Ez, sigma)
df <- data.frame(z, y, x)
set.seed(99)

bartFit1 <- bart(y ~ rob + hugh + ed + phil, df,
  keepevery = 10, ntree = 100, keeptrees = TRUE
)

bartFit2 <- bart(z ~ rob + hugh + ed + phil, df,
  keepevery = 10, ntree = 100, keeptrees = TRUE
)

model.list <- list(bartFit1, bartFit2)

multipartial(
  modl = model.list, spnames = c("Y", "Z"),
  x.vars = c("rob", "hugh"),
  smooth = 7, trace = TRUE, panels = TRUE
)

}
